<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>ã²ã‚‰ãŒãªãƒãƒˆãƒ«ï¼ã€ãƒœã‚¹æ’ƒç ´æ¼”å‡ºå¼·åŒ–ç‰ˆã€‘</title>

  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Klee+One:wght@600&display=swap"
  />

  <style>
    /* ===== æ•™ç§‘æ›¸ä½“ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼šæ¸¸æ•™ç§‘æ›¸ä½“ â†’ UDæ•™ç§‘æ›¸ä½“ â†’ Klee One â†’ æ±ç”¨ï¼‰ ===== */
    :root{
      --kyokasho-stack:
        /* iOSã®æ¸¸æ•™ç§‘æ›¸ä½“ï¼ˆè‹±å/åˆ¥å/æ—¥åï¼‰ */
        "Yu Kyokasho","YuKyo","YuKyo-Medium","Yu Kyokasho Yoko","YuKyo_Yoko-Medium",
        "æ¸¸æ•™ç§‘æ›¸ä½“","æ¸¸æ•™ç§‘æ›¸ä½“ æ¨ªç”¨",
        /* ç«¯æœ«ã«å…¥ã£ã¦ã„ã‚Œã°UDæ•™ç§‘æ›¸ä½“ */
        "UD Digi Kyokasho N-R","UDãƒ‡ã‚¸ã‚¿ãƒ«æ•™ç§‘æ›¸ä½“ N-R",
        /* æœ€å¾Œã«Klee Oneã¨æ±ç”¨ */
        "Klee One", serif;
    }

    body {
      margin: 0;
      text-align: center;
      color: white;
      font-family: var(--kyokasho-stack);
      overflow: hidden;
      transition: background 1s;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      justify-content: space-around;
      padding: 10px;
      box-sizing: border-box;
    }

    #enemy-area {
      height: 25vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: visible;
    }

    #enemy {
      font-size: 80px;
      transition: all 0.3s;
      margin-bottom: 5px;
      display: inline-block;
      position: relative;
      z-index: 1;
      transform-origin: center top;
      font-family: var(--kyokasho-stack);
    }
    #enemy.boss {
      font-size: 130px;
      animation: boss-idle 2s infinite alternate;
    }

    /* HPãƒãƒ¼ */
    #hp-container {
      width: 220px; height: 18px;
      background: #ff4757;
      border: 2px solid #fff; border-radius: 10px;
      position: relative; overflow: hidden;
      box-sizing: content-box;
      z-index: 10;
      flex: 0 0 auto;
    }
    #hp-bar {
      width: 100%; height: 18px;
      background: #2ed573;
      transition: width 0.5s ease-out;
      position: absolute; left: 0; top: 0;
      z-index: 5;
    }

    #draw-area {
      position: relative; width: 320px; height: 320px;
      background: white; border: 5px solid #555; border-radius: 15px;
      box-sizing: content-box; overflow: hidden;
    }
    canvas { position: absolute; top: 0; left: 0; touch-action: none; width: 320px; height: 320px; }
    .line-v { position: absolute; left: 160px; top: 0; bottom: 0; border-left: 1px dashed #eee; z-index: 0; }
    .line-h { position: absolute; top: 160px; left: 0; right: 0; border-top: 1px dashed #eee; z-index: 0; }

    #footer { display: flex; flex-direction: column; gap: 10px; align-items: center; }
    #btn-decision { width: 260px; height: 75px; font-size: 32px; font-weight: bold; background: #ff4757; color: white; border: none; border-radius: 40px; box-shadow: 0 8px #a70000; cursor: pointer; font-family: var(--kyokasho-stack); }
    #btn-undo     { width: 160px; height: 45px; font-size: 18px; font-weight: bold; background: #54a0ff; color: white; border: none; border-radius: 25px; box-shadow: 0 4px #2e86de; cursor: pointer; font-family: var(--kyokasho-stack); }
    #btn-skip     { width: 100px; height: 30px; font-size: 14px; background: #666; color: white; border: none; border-radius: 15px; cursor: pointer; margin-top: 5px; font-family: var(--kyokasho-stack); }

    button:active { transform: translateY(4px); box-shadow: none; }

    #msg { height: 40px; font-size: 22px; color: #ffd32a; font-weight: bold; text-shadow: 2px 2px 2px #000; font-family: var(--kyokasho-stack); }
    #stage-info { font-size: 18px; color: #fff; margin-bottom: 5px; font-family: var(--kyokasho-stack); }

    .shake-s { animation: shake-s 0.3s; }
    .shake-m { animation: shake-m 0.4s; }
    .shake-l { animation: shake-l 0.5s; }
    @keyframes shake-s { 0%{transform:translate(0,0)} 25%{transform:translate(-5px,0)} 75%{transform:translate(5px,0)} 100%{transform:translate(0,0)} }
    @keyframes shake-m { 0%{transform:translate(0,0)} 20%{transform:translate(-15px,5px)} 40%{transform:translate(15px,-5px)} 60%{transform:translate(-10px,5px)} 80%{transform:translate(10px,-5px)} 100%{transform:translate(0,0)} }
    @keyframes shake-l { 0%{transform:scale(1) translate(0,0)} 20%{transform:scale(1.3) translate(-20px,10px)} 40%{transform:scale(0.8) translate(20px,-10px)} 60%{transform:scale(1.4) translate(-15px,10px)} 80%{transform:scale(0.9) translate(15px,-10px)} 100%{transform:scale(1) translate(0,0)} }
    @keyframes boss-idle { 0%{transform:scale(1);} 100%{transform:scale(1.1);} }

    .boss-warning { animation: flash 0.5s infinite; color: red !important; }
    @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

    .stage-clear-flash { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: white; z-index: 100; animation: fadeOut 1s; pointer-events: none; }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="enemy-area">
      <div id="stage-info">Stage 1</div>
      <div id="msg">ã˜ã‚…ã‚“ã³ä¸­...</div>
      <div id="enemy">ğŸ‘»</div>
      <div id="hp-container"><div id="hp-bar" style="width: 100%;"></div></div>
    </div>

    <div id="draw-area">
      <div class="line-v"></div>
      <div class="line-h"></div>
      <canvas id="guide-canvas" width="320" height="320"></canvas>
      <canvas id="draw-canvas"  width="320" height="320"></canvas>
    </div>

    <div id="footer">
      <button id="btn-undo">ã²ã¨ã¤ ã‚‚ã©ã‚‹</button>
      <button id="btn-decision">ã‘ã£ã¦ã„ï¼</button>
      <button id="btn-skip">ãƒœã‚¹ã¸</button>
    </div>
  </div>

  <script>
    const drawCanvas = document.getElementById('draw-canvas');
    const guideCanvas = document.getElementById('guide-canvas');
    const dctx = drawCanvas.getContext('2d', { willReadFrequently: true });
    const gctx = guideCanvas.getContext('2d', { willReadFrequently: true });
    const hpBar = document.getElementById('hp-bar');
    const msg = document.getElementById('msg');
    const enemy = document.getElementById('enemy');
    const stageInfo = document.getElementById('stage-info');
    const btnSkip = document.getElementById('btn-skip');

    let audioCtx = null;
    let firstInteracted = false;
    function getAudioCtx(){
      if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (Ctx) audioCtx = new Ctx();
      }
      return audioCtx;
    }
    function primeAudio() {
      const ctx = getAudioCtx();
      if (ctx && ctx.state === 'suspended') { ctx.resume(); }
      firstInteracted = true;
    }
    window.addEventListener('touchstart', primeAudio, { once: true, passive: true });
    window.addEventListener('mousedown',  primeAudio, { once: true });

    function playSound(type) {
      const ctx = getAudioCtx();
      if (!ctx) return;
      if (ctx.state === 'suspended') { ctx.resume(); }
      const now = ctx.currentTime;

      const make = (oscType, startHz, endHz, dur, gainVal, curve='expo') => {
        const osc  = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = oscType;
        osc.connect(gain); gain.connect(ctx.destination);
        osc.frequency.setValueAtTime(startHz, now);
        if (curve === 'expo') {
          osc.frequency.exponentialRampToValueAtTime(Math.max(1, endHz), now + dur);
        } else {
          osc.frequency.linearRampToValueAtTime(endHz, now + dur);
        }
        gain.gain.setValueAtTime(gainVal, now);
        gain.gain.linearRampToValueAtTime(0, now + dur);
        osc.start(); osc.stop(now + dur);
      };

      if (type === 'small') {
        make('sine', 440, 110, 0.10, 0.30, 'expo');
      } else if (type === 'medium') {
        make('triangle', 660, 40, 0.20, 0.40, 'expo');
      } else if (type === 'large') {
        make('sawtooth', 200, 20, 0.40, 0.50, 'linear');
      } else if (type === 'win') {
        [523.25, 659.25, 783.99].forEach((f, i) => {
          const t = now + i * 0.1;
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.connect(g); g.connect(ctx.destination);
          o.frequency.setValueAtTime(f, t);
          g.gain.setValueAtTime(0.2, t);
          g.gain.linearRampToValueAtTime(0, t + 0.3);
          o.start(t); o.stop(t + 0.3);
        });
      }
    }

    const hiraganas = "ã‚ã„ã†ãˆãŠã‹ããã‘ã“ã•ã—ã™ã›ããŸã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ã‚€ã‚ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚ã‚ã‚’ã‚“";
    let currentStage = 1;
    let enemiesToDefeat = 0;
    let isBossFighting = false;
    let maxHP = 100;
    let currentEnemyHP = 100;
    let historyStack = [];
    let drawing = false;
    const backgrounds = ["#222", "#4a148c", "#1a237e", "#004d40", "#bf360c"];

    let lastTarget = null;
    let bossChangedOnce  = false;
    let bossChangedTwice = false;

    const canvasFontFamily = `"Yu Kyokasho","YuKyo","YuKyo-Medium","Yu Kyokasho Yoko","YuKyo_Yoko-Medium",
                              "æ¸¸æ•™ç§‘æ›¸ä½“","æ¸¸æ•™ç§‘æ›¸ä½“ æ¨ªç”¨",
                              "UD Digi Kyokasho N-R","UDãƒ‡ã‚¸ã‚¿ãƒ«æ•™ç§‘æ›¸ä½“ N-R",
                              "Klee One", serif`;

    function initStage() {
      isBossFighting = false;
      enemiesToDefeat = Math.floor(Math.random() * 3) + 3;
      stageInfo.innerText = "Stage " + currentStage + " (é›‘é­š ã‚ã¨ " + enemiesToDefeat + "äºº)";
      document.body.style.backgroundColor = backgrounds[(currentStage - 1) % backgrounds.length];
      spawnEnemy(false);
      setNextQuestion();
    }

    function spawnEnemy(isBoss) {
      enemy.classList.remove('boss', 'boss-warning');
      if (isBoss) {
        enemy.innerText = "ğŸ²";
        enemy.classList.add('boss');
        maxHP = 300;
        bossChangedOnce  = false;
        bossChangedTwice = false;
      } else {
        const enemies = ["ğŸ‘¾", "ğŸ‘¹", "ğŸ‘»", "ğŸ¤–"];
        enemy.innerText = enemies[Math.floor(Math.random() * enemies.length)];
        maxHP = 100;
      }
      currentEnemyHP = maxHP;
      hpBar.style.width = "100%";
    }

    function chooseNextTarget(prev) {
      const len = hiraganas.length;
      if (len <= 1) return hiraganas[0];
      let t = prev;
      while (t === prev) {
        t = hiraganas[Math.floor(Math.random() * len)];
      }
      return t;
    }

    function setNextQuestion() {
      const target = chooseNextTarget(lastTarget);
      lastTarget = target;
      gctx.clearRect(0, 0, 320, 320);
      gctx.font = `600 300px ${canvasFontFamily}`;
      gctx.textAlign = "center"; gctx.textBaseline = "middle";
      const centerX = 160; const centerY = 135;
      gctx.fillStyle = "#f0f0f0"; gctx.fillText(target, centerX, centerY);
      gctx.strokeStyle = "#f0f0f0"; gctx.lineWidth = 15; gctx.strokeText(target, centerX, centerY);
      msg.innerText = "ã€Œ" + target + "ã€ã‚’ ã‹ã“ã†ï¼";
      dctx.clearRect(0, 0, 320, 320);
      historyStack = [];
    }

    if (document.fonts) {
      document.fonts.ready.then(function() { initStage(); });
    } else {
      window.onload = initStage;
    }

    function getPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      const scale = 320 / rect.width;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: (clientX - rect.left) * scale, y: (clientY - rect.top) * scale };
    }

    drawCanvas.addEventListener('touchstart', (e) => {
      if (!firstInteracted) primeAudio();
      historyStack.push(dctx.getImageData(0, 0, 320, 320));
      drawing = true;
      const pos = getPos(e);
      dctx.beginPath();
      dctx.moveTo(pos.x, pos.y);
      e.preventDefault();
    }, {passive: false});

    drawCanvas.addEventListener('touchmove', (e) => {
      if (!drawing) return;
      const pos = getPos(e);
      dctx.lineWidth = 26; dctx.lineCap = 'round'; dctx.lineJoin = 'round'; dctx.strokeStyle = '#333';
      dctx.lineTo(pos.x, pos.y);
      dctx.stroke();
      e.preventDefault();
    }, {passive: false});

    window.addEventListener('touchend', () => { drawing = false; });

    document.getElementById('btn-undo').onclick = () => {
      if (!firstInteracted) primeAudio();
      if (historyStack.length > 0) dctx.putImageData(historyStack.pop(), 0, 0);
    };

    btnSkip.onclick = () => {
      if (!firstInteracted) primeAudio();
      enemiesToDefeat = 1;
      currentEnemyHP = 0;
      applyDamage(100);
    };

    document.getElementById('btn-decision').onclick = function() {
      if (!firstInteracted) primeAudio();
      const drawData = dctx.getImageData(0,0,320,320).data;
      const guideData = gctx.getImageData(0,0,320,320).data;
      let match = 0, out = 0, guideTotal = 0;
      for (let i = 3; i < drawData.length; i += 4) {
        const isGuide = guideData[i] > 10; const isUser = drawData[i] > 10;
        if (isGuide) { guideTotal++; if (isUser) match++; } else { if (isUser) out++; }
      }
      let score  = ((match / guideTotal) - (out / guideTotal * 0.4)) * 150;
      let damage = score >= 65 ? 100 : score >= 45 ? 75 : score >= 25 ? 50 : score >= 10 ? 25 : 0;

      applyDamage(damage);
      dctx.clearRect(0, 0, 320, 320);

      if (!isBossFighting) {
        setNextQuestion();
      }
    };

    function applyDamage(dmg) {
      enemy.classList.remove('shake-s', 'shake-m', 'shake-l');
      void enemy.offsetWidth;
      let defeated = false;

      if (dmg > 0) {
        msg.innerText = dmg + "ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼";
        if (dmg === 100) { enemy.classList.add('shake-l'); playSound('win'); }
        else if (dmg === 75) { enemy.classList.add('shake-m'); playSound('medium'); }
        else { enemy.classList.add('shake-s'); playSound('small'); }

        currentEnemyHP -= dmg;
        if (currentEnemyHP < 0) currentEnemyHP = 0;
        hpBar.style.width = (currentEnemyHP / maxHP * 100) + "%";

        if (isBossFighting) {
          const totalDamage = maxHP - currentEnemyHP;
          if (!bossChangedTwice && totalDamage >= 200) {
            bossChangedTwice = true;
            playSound('medium');
            msg.innerText = "ãŠé¡ŒãŒ ã‹ã‚ã£ãŸï¼";
            setNextQuestion();
          } else if (!bossChangedOnce && totalDamage >= 100) {
            bossChangedOnce = true;
            playSound('medium');
            msg.innerText = "ãŠé¡ŒãŒ ã‹ã‚ã£ãŸï¼";
            setNextQuestion();
          }
        }

        if (currentEnemyHP <= 0) defeated = true;
      } else {
        msg.innerText = "ã¡ã‚ƒã‚“ã¨ãªãã£ã¦ã¿ã‚ˆã†ï¼";
      }

      if (defeated) {
        if (isBossFighting) {
          stageClearEffect();
        } else {
          enemy.innerText = "ğŸ’¥";
          playSound('large');
          enemiesToDefeat--;
          if (enemiesToDefeat > 0) {
            msg.innerText = "ã¤ãã® æ•µã ï¼";
            stageInfo.innerText = "Stage " + currentStage + " (é›‘é­š ã‚ã¨ " + enemiesToDefeat + "äºº)";
            setTimeout(() => { spawnEnemy(false); }, 800);
          } else {
            setTimeout(() => { bossWarning(); }, 800);
          }
        }
      }
    }

    function bossWarning() {
      msg.innerText = "ãƒœã‚¹ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼";
      stageInfo.innerText = "Stage " + currentStage + " BOSS";
      enemy.classList.add('boss-warning');
      playSound('large');
      setTimeout(() => {
        isBossFighting = true;
        spawnEnemy(true);
        setNextQuestion();
      }, 1500);
    }

    /* ===== â˜… ä¿®æ­£ï¼šãƒœã‚¹æ’ƒç ´æ™‚ã®é€£ç¶šçˆ†ç™ºæ¼”å‡º ===== */
    function stageClearEffect() {
      msg.innerText = "ãƒœã‚¹ã‚’ ãŸãŠã—ãŸï¼ï¼";
      
      // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
      const flash = document.createElement('div');
      flash.className = 'stage-clear-flash';
      document.body.appendChild(flash);
      setTimeout(() => document.body.removeChild(flash), 1000);

      // 5å›é€£ç¶šçˆ†ç™ºæ¼”å‡º
      let explosionCount = 0;
      const interval = setInterval(() => {
        enemy.innerText = "ğŸ’¥";
        playSound('large'); // ãƒ‰ãƒ³ï¼
        
        // æ¿€ã—ãæºã‚‰ã™
        enemy.classList.remove('shake-l');
        void enemy.offsetWidth; 
        enemy.classList.add('shake-l');

        explosionCount++;
        if (explosionCount >= 5) {
          clearInterval(interval);
          
          // å…¨çˆ†ç™ºçµ‚äº†å¾Œã«æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
          setTimeout(() => {
            currentStage++;
            initStage();
          }, 1000);
        }
      }, 200); // 0.2ç§’é–“éš”ã§ãƒ‰ãƒ³ãƒ‰ãƒ³ãƒ‰ãƒ³ãƒ‰ãƒ³ï¼
    }

    /* ===== PCãƒ‡ãƒãƒƒã‚°ç”¨ï¼šãƒã‚¦ã‚¹ã§ã‚‚æã‘ã‚‹ã‚ˆã†ã« ===== */
    drawCanvas.addEventListener('mousedown', (e) => {
      if (!firstInteracted) primeAudio();
      if (e.button !== 0) return;
      historyStack.push(dctx.getImageData(0, 0, 320, 320));
      drawing = true;
      const pos = getPos(e);
      dctx.beginPath();
      dctx.moveTo(pos.x, pos.y);
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const pos = getPos(e);
      dctx.lineWidth = 26; dctx.lineCap = 'round'; dctx.lineJoin = 'round'; dctx.strokeStyle = '#333';
      dctx.lineTo(pos.x, pos.y);
      dctx.stroke();
    });
    window.addEventListener('mouseup', () => { drawing = false; });
    drawCanvas.addEventListener('mouseleave', () => { drawing = false; });
    drawCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
  </script>
</body>
</html>
